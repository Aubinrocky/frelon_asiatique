<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Carte des signalements ‚Äì Frelon asiatique (Hotspots)</title>

  <!-- Leaflet core -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY=" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo=" crossorigin=""></script>

  <!-- MarkerCluster -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
  <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

  <!-- Heatmap plugin -->
  <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>

  <!-- Turf.js (g√©otraitements: DBSCAN, convex hull, centroid, buffer, etc.) -->
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@6/turf.min.js"></script>

  <style>
    :root {
      --bg: #0b1020;
      --panel: #131b33;
      --panel-2: #0f1730;
      --muted: #9fb0d0;
      --accent: #6ae28a;   /* frelon points */
      --accent-2: #e26a6a; /* nids */
      --accent-3: #7ab6ff; /* hotspots */
      --text: #e6ecff;
      --chip: #0e1630;
      --border: #243058;
    }

    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
    #app { display: grid; grid-template-rows: auto auto 1fr; height: 100%; }

    header {
      display: flex; gap: 12px; align-items: center; padding: 10px 14px; background: var(--panel); border-bottom: 1px solid #202a4a;
    }
    header h1 { font-size: 16px; margin: 0; font-weight: 600; }

    .controls { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; align-items: center; padding: 8px 14px; background: var(--panel-2); border-bottom: 1px solid #202a4a; }

    .group { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .badge { padding: 4px 8px; border-radius: 999px; font-size: 12px; background: var(--chip); border: 1px solid var(--border); }
    .legend { display: flex; gap: 12px; align-items: center; }
    .dot { width: 10px; height: 10px; border-radius: 999px; display: inline-block; margin-right: 6px; }
    .dot-frelon { background: var(--accent); }
    .dot-nid { background: var(--accent-2); }
    .dot-hot { background: var(--accent-3); }

    .btn { background: #1a2240; color: var(--text); border: 1px solid #2a3869; border-radius: 10px; padding: 6px 10px; cursor: pointer; font-size: 14px; }
    .btn:hover { background: #212c52; }
    .btn.alt { background: transparent; border: 1px dashed #3a4b7c; }
    .input, .select { background: #0f1730; color: var(--text); border: 1px solid var(--border); border-radius: 10px; padding: 6px 10px; font-size: 14px; }
    .mini { font-size: 12px; opacity: .9; }

    #map { width: 100%; height: calc(100vh - 120px); }

    .leaflet-popup-content { color: #0b1020; }

    .toast { position: fixed; top: 12px; right: 12px; background: #0e1630; border: 1px solid #243058; color: var(--text); padding: 10px 12px; border-radius: 12px; font-size: 13px; box-shadow: 0 6px 24px rgba(0,0,0,0.25); display: none; }
    .toast.show { display: block; }

    .pill { display:inline-flex; align-items:center; gap:6px; padding:3px 8px; border-radius:999px; background:#0f1730; border:1px solid #273461; font-size:12px; }
    .pill input { margin:0 }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>Carte des signalements ‚Äì Frelon asiatique</h1>
      <div class="group">
        <span id="countBadge" class="badge">Chargement‚Ä¶</span>
        <div class="legend mini">
          <span class="pill"><span class="dot dot-frelon"></span> Obser. frelons</span>
          <span class="pill"><span class="dot dot-nid"></span> Nids signal√©s</span>
          <span class="pill"><span class="dot dot-hot"></span> Zones probables</span>
        </div>
      </div>
      <div class="group">
        <button id="locateBtn" class="btn">üìç Autour de moi</button>
        <a class="btn" href="#" id="refreshBtn">üîÑ Actualiser</a>
      </div>
    </header>

    <!-- Filtres et param√®tres d'analyse -->
    <div class="controls">
      <div class="group">
        <label class="pill"><input type="checkbox" id="toggleFrelon" checked> Frelons</label>
        <label class="pill"><input type="checkbox" id="toggleNid" checked> Nids</label>
        <label class="pill"><input type="checkbox" id="toggleClusters" checked> Clusters</label>
        <label class="pill"><input type="checkbox" id="toggleHeat" checked> Heatmap</label>
      </div>
      <div class="group">
        <label>Fen√™tre temporelle
          <select id="timeWindow" class="select">
            <option value="30">30 j</option>
            <option value="60" selected>60 j</option>
            <option value="90">90 j</option>
            <option value="180">180 j</option>
            <option value="99999">Tous</option>
          </select>
        </label>
        <label>Rayon cluster (m)
          <input id="clusterRadius" class="input" type="number" min="100" step="50" value="600" />
        </label>
        <label>Min. points/cluster
          <input id="minPts" class="input" type="number" min="2" step="1" value="3" />
        </label>
        <label>Rayon zone (m)
          <input id="zoneRadius" class="input" type="number" min="50" step="25" value="200" />
        </label>
        <button id="recomputeBtn" class="btn">üß† Recalculer</button>
        <button id="exportBtn" class="btn alt">‚¨áÔ∏è Exporter zones (.geojson)</button>
      </div>
    </div>

    <div id="map"></div>
  </div>

  <div id="toast" class="toast">Position introuvable.</div>

  <!-- Firebase v9 (modular) CDN -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getFirestore, collection, getDocs, query, orderBy } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

    // üëâ config Firebase (remets les tiens si besoin)
    const firebaseConfig = {
      apiKey: "AIzaSyDBhvHztC4w2MYbQG2rTtdJgMiKMo4vos4",
      authDomain: "frelonsasiatiques-d71cc.firebaseapp.com",
      projectId: "frelonsasiatiques-d71cc",
      storageBucket: "frelonsasiatiques-d71cc.firebasestorage.app",
      messagingSenderId: "895220865652",
      appId: "1:895220865652:web:f9c3656604e4b8bb048f21",
      measurementId: "G-P6X6Z218K8"
    };

    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // ------- Leaflet map -------
    const map = L.map('map', { zoomControl: true, attributionControl: true }).setView([46.7, 2.5], 6);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19, attribution: '&copy; OpenStreetMap contributors' }).addTo(map);

    // Layers
    const layerMarkers = L.markerClusterGroup({ showCoverageOnHover: false, disableClusteringAtZoom: 13 });
    const layerNids = L.layerGroup();
    const layerHeat = L.heatLayer([], { radius: 24, blur: 16, maxZoom: 14 });
    const layerHotspotsPolygons = L.layerGroup();
    const layerHotspotsCentroids = L.layerGroup();

    layerMarkers.addTo(map);
    layerNids.addTo(map);
    layerHeat.addTo(map);
    layerHotspotsPolygons.addTo(map);
    layerHotspotsCentroids.addTo(map);

    // State
    const state = {
      raw: [], // {type, lat, lng, quantity, date, description}
      frelons: [],
      nids: [],
      hotspotsGeojson: null,
    };

    const colors = { frelon: '#6ae28a', nid: '#e26a6a', hot: '#7ab6ff' };

    // ------- Utils dates -------
    function toJsDate(val) {
      if (!val) return null;
      if (val && typeof val.toDate === 'function') return val.toDate();
      if (val instanceof Date) return isNaN(val.getTime()) ? null : val;
      if (typeof val === 'number') {
        const d = new Date(val < 1e12 ? val * 1000 : val);
        return isNaN(d.getTime()) ? null : d;
      }
      if (typeof val === 'string') {
        const s = val.trim();
        if (/^\d{4}-\d{2}-\d{2}$/.test(s)) {
          const d = new Date(s + 'T00:00:00Z');
          return isNaN(d.getTime()) ? null : d;
        }
        const d = new Date(s);
        return isNaN(d.getTime()) ? null : d;
      }
      return null;
    }
    function formatDate(val) {
      const d = toJsDate(val);
      if (!d) return '‚Äî';
      const dd = String(d.getDate()).padStart(2, '0');
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const yyyy = d.getFullYear();
      return `${dd}-${mm}-${yyyy}`;
    }

    // ------- Weighting -------
    function recencyWeight(date, halfLifeDays = 30) {
      const d = toJsDate(date);
      if (!d) return 0.5; // neutre si date manquante
      const now = Date.now();
      const dt = (now - d.getTime()) / 86400000; // jours
      const lambda = Math.log(2) / halfLifeDays; // d√©croissance exponentielle
      const w = Math.exp(-lambda * dt);
      return Math.max(0, Math.min(1, w));
    }

    // ------- UI helpers -------
    const $ = (id) => document.getElementById(id);
    const toast = (msg) => { const el = $('toast'); el.textContent = msg; el.classList.add('show'); setTimeout(() => el.classList.remove('show'), 2400); };

    // ------- Markers -------
    function makeCircleMarker(d) {
      const color = d.type === 'nid' ? colors.nid : colors.frelon;
      const marker = L.circleMarker([d.lat, d.lng], {
        radius: Math.min(14, 6 + (Number(d.quantity)||0)),
        color, fillColor: color, fillOpacity: 0.6, weight: 2
      });
      const title = d.type === 'nid' ? 'Nid signal√©' : 'Frelons observ√©s';
      const quantity = (d.quantity ?? '‚Äî');
      marker.bindPopup(`
        <strong>${title}</strong><br>
        Quantit√© : ${quantity}<br>
        Vu le : ${formatDate(d.date)}
      `);
      marker.__type = d.type;
      return marker;
    }

    // ------- Layers update -------
    function applyVisibility() {
      const showFrelon = $('toggleFrelon').checked;
      const showNid = $('toggleNid').checked;
      const showHeat = $('toggleHeat').checked;
      const showClusters = $('toggleClusters').checked;

      if (showFrelon) map.addLayer(layerMarkers); else map.removeLayer(layerMarkers);
      if (showNid) map.addLayer(layerNids); else map.removeLayer(layerNids);
      if (showHeat) map.addLayer(layerHeat); else map.removeLayer(layerHeat);
      if (showClusters) { map.addLayer(layerHotspotsPolygons); map.addLayer(layerHotspotsCentroids); }
      else { map.removeLayer(layerHotspotsPolygons); map.removeLayer(layerHotspotsCentroids); }
    }

    function fitToVisible() {
      const groups = [];
      if (map.hasLayer(layerMarkers) && layerMarkers.getLayers().length) groups.push(layerMarkers);
      if (map.hasLayer(layerNids) && layerNids.getLayers().length) groups.push(layerNids);
      if (!groups.length) return;
      const fg = L.featureGroup(groups.flatMap(g => g.getLayers ? g.getLayers() : []));
      if (fg.getLayers().length) map.fitBounds(fg.getBounds().pad(0.2));
    }

    // ------- Analysis: Heatmap & Hotspots -------
    function filterByTime(data) {
      const days = Number($('timeWindow').value);
      if (days >= 99999) return data;
      const minTs = Date.now() - days * 86400000;
      return data.filter(d => {
        const t = toJsDate(d.date)?.getTime();
        return t ? (t >= minTs) : true;
      });
    }

    function rebuildHeatmap() {
      const halfLife = Math.max(7, Math.floor(Number($('timeWindow').value) / 2));
      const points = filterByTime(state.frelons).map(d => {
        const w = Math.max(0.1, Math.min(1, (Number(d.quantity)||1) * recencyWeight(d.date, halfLife)));
        return [d.lat, d.lng, w];
      });
      layerHeat.setLatLngs(points);
    }

    function rebuildHotspots() {
      layerHotspotsPolygons.clearLayers();
      layerHotspotsCentroids.clearLayers();

      const clusterRadiusM = Number($('clusterRadius').value || 600);
      const minPts = Number($('minPts').value || 3);
      const zoneRadiusM = Number($('zoneRadius').value || 200);

      const frelons = filterByTime(state.frelons);
      if (!frelons.length) return;

      // Build a Turf FeatureCollection of frelon observations
      const features = frelons.map(d => turf.point([d.lng, d.lat], {
        quantity: Number(d.quantity)||1,
        ts: toJsDate(d.date)?.getTime() || null
      }));
      const fc = turf.featureCollection(features);

      // DBSCAN clustering in meters
      const clustered = turf.clustersDbscan(fc, clusterRadiusM / 1000, { units: 'kilometers', minPoints: minPts });

      // Group points by cluster id (exclude noise: cluster = 'noise')
      const byId = new Map();
      for (const f of clustered.features) {
        const id = f.properties.cluster;
        if (id === 'noise' || id === undefined || id === null) continue;
        if (!byId.has(id)) byId.set(id, []);
        byId.get(id).push(f);
      }

      const halfLife = Math.max(7, Math.floor(Number($('timeWindow').value) / 2));

      const zones = [];
      for (const [id, pts] of byId.entries()) {
        // Weighted centroid by quantity * recencyWeight
        let sumW = 0, sx = 0, sy = 0;
        let maxTs = 0, minTs = Infinity;
        for (const p of pts) {
          const [x, y] = p.geometry.coordinates; // lng, lat
          const w = (p.properties.quantity || 1) * recencyWeight(p.properties.ts, halfLife);
          sumW += w; sx += x * w; sy += y * w;
          if (p.properties.ts) { maxTs = Math.max(maxTs, p.properties.ts); minTs = Math.min(minTs, p.properties.ts); }
        }
        const cx = sx / (sumW || pts.length);
        const cy = sy / (sumW || pts.length);

        // Hull (convex). If fails (1-2 points), fallback to small circle only.
        let hull = null;
        try { hull = turf.convex(turf.featureCollection(pts)); } catch(_) {}

        // Confidence score (0..1) ~ normalized by points count and compactness
        const count = pts.length;
        let score = Math.min(1, (count - (minPts - 1)) / 6); // crude: more points -> higher
        if (hull) {
          const area = turf.area(hull); // m¬≤
          const dens = count / Math.max(1, area / 1e6); // pts / km¬≤
          score = Math.max(score, Math.min(1, dens / 20));
        }

        zones.push({ id, centroid: [cy, cx], centroidLngLat: [cx, cy], pts, hull, score });
      }

      // Draw
      for (const z of zones) {
        // Polygon (hull)
        if (z.hull) {
          const poly = L.polygon(z.hull.geometry.coordinates[0].map(([lng, lat]) => [lat, lng]), {
            color: colors.hot, weight: 1.5, fillColor: colors.hot, fillOpacity: 0.15, dashArray: '4,6'
          });
          poly.addTo(layerHotspotsPolygons);
        }
        // Search circle around centroid (zone probable √† inspecter)
        const circle = L.circle(z.centroid, { radius: Number($('zoneRadius').value || 200), color: colors.hot, weight: 2, fillColor: colors.hot, fillOpacity: 0.25 });
        circle.addTo(layerHotspotsPolygons);

        // Centroid marker
        const mk = L.circleMarker(z.centroid, { radius: 8, color: '#1a7bff', weight: 2, fillColor: '#cfe2ff', fillOpacity: 0.9 });
        const lastSeen = z.pts.map(p => p.properties.ts).filter(Boolean).sort((a,b)=>b-a)[0];
        const daysAgo = lastSeen ? Math.round((Date.now() - lastSeen)/86400000) : null;
        mk.bindPopup(`
          <strong>Zone probable de nid</strong><br>
          Taille cluster : ${z.pts.length}<br>
          Score (0-1) : ${z.score.toFixed(2)}<br>
          Derni√®re observation : ${daysAgo!=null ? daysAgo+" j" : '‚Äî'}
        `);
        mk.addTo(layerHotspotsCentroids);
      }

      // Stockage pour export
      state.hotspotsGeojson = {
        type: 'FeatureCollection',
        features: zones.map(z => ({
          type: 'Feature',
          properties: {
            id: z.id,
            count: z.pts.length,
            score: Number(z.score.toFixed(3)),
          },
          geometry: z.hull ? z.hull.geometry : turf.circle(z.centroidLngLat, ($('zoneRadius').value||200)/1000, {steps: 32, units:'kilometers'}).geometry
        }))
      };
    }

    // ------- Data load & pipeline -------
    async function loadData() {
      $('countBadge').textContent = 'Chargement‚Ä¶';

      // Clear layers
      layerMarkers.clearLayers();
      layerNids.clearLayers();
      layerHeat.setLatLngs([]);
      layerHotspotsPolygons.clearLayers();
      layerHotspotsCentroids.clearLayers();

      const q = query(collection(db, 'declaration'), orderBy('date', 'desc'));
      const snap = await getDocs(q);

      state.raw = []; state.frelons = []; state.nids = [];

      snap.forEach(doc => {
        const d = doc.data();
        if (typeof d.lat !== 'number' || typeof d.lng !== 'number') return;
        const type = (d.type === 'nid') ? 'nid' : 'frelon';
        const item = {
          type,
          lat: d.lat,
          lng: d.lng,
          quantity: typeof d.quantity === 'number' ? d.quantity : Number(d.quantity) || 0,
          date: d.date ?? null,
          description: d.description ?? ''
        };
        state.raw.push(item);
        if (type === 'frelon') state.frelons.push(item); else state.nids.push(item);
      });

      // Draw points
      for (const item of state.frelons) layerMarkers.addLayer(makeCircleMarker(item));
      for (const item of state.nids) layerNids.addLayer(makeCircleMarker(item));

      rebuildHeatmap();
      rebuildHotspots();

      applyVisibility();
      fitToVisible();

      $('countBadge').textContent = `${state.raw.length} signalement(s)`;
    }

    // ------- Export -------
    function exportGeoJSON() {
      if (!state.hotspotsGeojson) { toast('Rien √† exporter.'); return; }
      const blob = new Blob([JSON.stringify(state.hotspotsGeojson, null, 2)], { type: 'application/geo+json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = `zones_probables_${new Date().toISOString().slice(0,10)}.geojson`;
      a.click();
      URL.revokeObjectURL(url);
    }

    // ------- UI bindings -------
    $('toggleFrelon').addEventListener('change', applyVisibility);
    $('toggleNid').addEventListener('change', applyVisibility);
    $('toggleHeat').addEventListener('change', applyVisibility);
    $('toggleClusters').addEventListener('change', applyVisibility);

    $('timeWindow').addEventListener('change', () => { rebuildHeatmap(); rebuildHotspots(); applyVisibility(); });
    $('clusterRadius').addEventListener('change', () => { rebuildHotspots(); applyVisibility(); });
    $('minPts').addEventListener('change', () => { rebuildHotspots(); applyVisibility(); });
    $('zoneRadius').addEventListener('change', () => { rebuildHotspots(); applyVisibility(); });

    $('recomputeBtn').addEventListener('click', () => { rebuildHeatmap(); rebuildHotspots(); applyVisibility(); fitToVisible(); });

    $('exportBtn').addEventListener('click', (e) => { e.preventDefault(); exportGeoJSON(); });

    $('refreshBtn').addEventListener('click', (e) => { e.preventDefault(); loadData().catch(err => { console.error(err); toast('Erreur de chargement des donn√©es'); $('countBadge').textContent = 'Erreur'; }); });

    $('locateBtn').addEventListener('click', () => {
      if (!navigator.geolocation) return toast('G√©olocalisation non support√©e.');
      navigator.geolocation.getCurrentPosition(
        pos => { const { latitude, longitude } = pos.coords; map.setView([latitude, longitude], 13); },
        () => toast('Position introuvable.')
      );
    });

    // ------- Boot -------
    loadData().catch(err => { console.error(err); toast('Erreur de chargement des donn√©es'); $('countBadge').textContent = 'Erreur'; });
  </script>
</body>
</html>
