<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Carte des signalements ‚Äì Frelon asiatique (MVP)</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    :root {
      --bg: #0b1020;
      --panel: #131b33;
      --muted: #9fb0d0;
      --accent: #6ae28a;
      --accent-2: #e26a6a;
      --text: #e6ecff;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
    #app { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    header { display: flex; gap: 12px; align-items: center; padding: 10px 14px; background: var(--panel); border-bottom: 1px solid #202a4a; }
    header h1 { font-size: 16px; margin: 0; font-weight: 600; }
    .controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .badge { padding: 4px 8px; border-radius: 999px; font-size: 12px; background: #0e1630; border: 1px solid #243058; }
    .legend { display: flex; gap: 12px; align-items: center; }
    .dot { width: 10px; height: 10px; border-radius: 999px; display: inline-block; margin-right: 6px; }
    .dot-frelon { background: var(--accent); }
    .dot-nid { background: var(--accent-2); }
    #map { width: 100%; height: calc(100vh - 62px); }
    .btn { background: #1a2240; color: var(--text); border: 1px solid #2a3869; border-radius: 10px; padding: 6px 10px; cursor: pointer; font-size: 14px; }
    .btn:hover { background: #212c52; }
    .leaflet-popup-content { color: #0b1020; }
    .toast { position: fixed; top: 12px; right: 12px; background: #0e1630; border: 1px solid #243058; color: var(--text); padding: 10px 12px; border-radius: 12px; font-size: 13px; box-shadow: 0 6px 24px rgba(0,0,0,0.25); display: none; }
    .toast.show { display: block; }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>Carte des signalements ‚Äì Frelon asiatique</h1>
      <div class="controls">
        <span id="countBadge" class="badge">Chargement‚Ä¶</span>
        <div class="legend">
          <label><span class="dot dot-frelon"></span><input type="checkbox" id="toggleFrelon" checked> Frelons</label>
          <label><span class="dot dot-nid"></span><input type="checkbox" id="toggleNid" checked> Nids</label>
          <label><input type="checkbox" id="toggleZones" checked> Zone probable</label>
        </div>
        <button id="locateBtn" class="btn">üìç Autour de moi</button>
        <a class="btn" href="#" id="refreshBtn">üîÑ Actualiser</a>
      </div>
    </header>
    <div id="map"></div>
  </div>

  <div id="toast" class="toast">Position introuvable.</div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- Plugin Heatmap pour Leaflet -->
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

  <!-- Firebase v9 (modular) CDN -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getFirestore, collection, getDocs, query, orderBy } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

    // üëâ config Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyDBhvHztC4w2MYbQG2rTtdJgMiKMo4vos4",
      authDomain: "frelonsasiatiques-d71cc.firebaseapp.com",
      projectId: "frelonsasiatiques-d71cc",
      storageBucket: "frelonsasiatiques-d71cc.firebasestorage.app",
      messagingSenderId: "895220865652",
      appId: "1:895220865652:web:f9c3656604e4b8bb048f21",
      measurementId: "G-P6X6Z218K8"
    };

    // Init Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // ------- Leaflet map -------
    const map = L.map('map', { zoomControl: true, attributionControl: true }).setView([46.7, 2.5], 6); // Vue g√©n√©rale France
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const state = {
      markers: [],
      raw: [],
      heatLayer: null,       // heatmap
      probLayers: [],        // cercles de zone probable
      filters: { frelon: true, nid: true },
      showZones: true
    };

    const colors = {
      frelon: '#6ae28a', // vert
      nid: '#e26a6a'     // rouge
    };

    // ----- R√©glages (favoriser la QUANTIT√â de frelons) -----
    const NEST = {
      TIME_WINDOW_DAYS: 21,   // on garde les frelons ‚â§ 21 jours
      TAU_DAYS: 14,           // d√©croissance du poids avec l'√¢ge (jours)
      BETA: 1.0,              // poids quantit√© dans S(x) (lin√©aire)
      BETA_CLUSTER: 1.0,      // poids quantit√© pour le clustering (lin√©aire)
      MIN_CLUSTER_WEIGHT: 6,  // seuil de "densit√©" (‚âà 6 frelons √©quivalents)
      Q_MAX: 50,              // anti-outliers: on borne q √† 50
      R95_M: 1000,            // port√©e typique (95% des trajets)
      GRID_STEP_M: 250,       // pas de grille (m)
      PROB_P: 0.6             // cercle √† p=60%
    };
    NEST.SIGMA_M = NEST.R95_M / 2.447; // ‚âà 408 m si R95=1000 m

    // --- Aides g√©o ---
    function toRad(d){ return d*Math.PI/180; }
    function haversineMeters(a, b){
      const R = 6371000;
      const dLat = toRad(b.lat - a.lat);
      const dLng = toRad(b.lng - a.lng);
      const sa = Math.sin(dLat/2), sb = Math.sin(dLng/2);
      const h = sa*sa + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*sb*sb;
      return 2*R*Math.asin(Math.sqrt(h));
    }
    function metersToDegLat(m){ return m / 111320; }
    function metersToDegLng(m, lat){ return m / (111320 * Math.cos(toRad(lat))); }

    // --- DBSCAN pond√©r√© (par somme des poids au voisinage) ---
    function dbscanWeighted(points, weights, epsMeters, minWeight){
      const n = points.length;
      const labels = Array(n).fill(-1); // -1: non visit√©, -2: bruit, >=0: cluster id
      let cid = 0;

      function neighbors(i){
        const idxs = [];
        for (let j=0;j<n;j++){
          if (i===j) continue;
          if (haversineMeters(points[i], points[j]) <= epsMeters) idxs.push(j);
        }
        return idxs;
      }
      function neighWeight(i, neighIdxs){
        let s = weights[i];
        for (const j of neighIdxs) s += weights[j];
        return s;
      }

      for (let i=0;i<n;i++){
        if (labels[i] !== -1) continue;
        const neigh = neighbors(i);
        if (neighWeight(i, neigh) < minWeight){ labels[i] = -2; continue; } // bruit
        labels[i] = cid;
        const seeds = [...neigh];
        for (let k=0;k<seeds.length;k++){
          const j = seeds[k];
          if (labels[j] === -2) labels[j] = cid;
          if (labels[j] !== -1) continue;
          labels[j] = cid;
          const nj = neighbors(j);
          if (neighWeight(j, nj) >= minWeight){
            for (const x of nj){ if (!seeds.includes(x)) seeds.push(x); }
          }
        }
        cid++;
      }
      return {labels, clusters: cid};
    }

    // --- Dates robustes ---
    function toJsDate(val) {
      if (!val) return null;
      if (val && typeof val.toDate === 'function') return val.toDate();
      if (val instanceof Date) return isNaN(val.getTime()) ? null : val;
      if (typeof val === 'number') {
        const d = new Date(val < 1e12 ? val * 1000 : val);
        return isNaN(d.getTime()) ? null : d;
      }
      if (typeof val === 'string') {
        const s = val.trim();
        if (/^\d{4}-\d{2}-\d{2}$/.test(s)) {
          const d = new Date(s + 'T00:00:00Z');
          return isNaN(d.getTime()) ? null : d;
        }
        const d = new Date(s);
        return isNaN(d.getTime()) ? null : d;
      }
      return null;
    }

    function formatDate(val) {
      const d = toJsDate(val);
      if (!d) return '‚Äî';
      const dd = String(d.getDate()).padStart(2, '0');
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const yyyy = d.getFullYear();
      return `${dd}-${mm}-${yyyy}`;
    }

    // --- Markers ---
    function makeMarker(d) {
      const color = d.type === 'nid' ? colors.nid : colors.frelon;
      const marker = L.circleMarker([d.lat, d.lng], {
        radius: Math.min(14, 6 + (Number(d.quantity) || 0)),
        color,
        fillColor: color,
        fillOpacity: 0.6,
        weight: 2
      });

      const title = d.type === 'nid' ? 'Nid signal√©' : 'Frelons observ√©s';
      const quantity = (d.quantity ?? '‚Äî');
      let seen = '‚Äî';
      try { seen = formatDate(d.date); } catch(_) {}

      marker.bindPopup(
        `<strong>${title}</strong><br>
         Quantit√© : ${quantity}<br>
         Vu le : ${seen}`
      );
      marker.__type = d.type;
      return marker;
    }

    function escapeHtml(str) {
      return String(str)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    function applyFilters() {
      state.markers.forEach(m => {
        const visible =
          (m.__type === 'nid' && state.filters.nid) ||
          (m.__type === 'frelon' && state.filters.frelon);
        if (visible) m.addTo(map); else map.removeLayer(m);
      });
      // Heatmap et zones probables g√©r√©es s√©par√©ment.
    }

    function fitToData() {
      const visible = state.markers.filter(m => map.hasLayer(m));
      if (!visible.length) return;
      const group = L.featureGroup(visible);
      map.fitBounds(group.getBounds().pad(0.2));
    }

    // --- Construction des zones probables de nid (quantit√© prioritaire) ---
    function buildProbableZones() {
      // Supprimer anciens cercles
      state.probLayers.forEach(l => map.removeLayer(l));
      state.probLayers = [];

      // Filtrer frelons r√©cents
      const now = Date.now();
      const fresh = state.raw
        .filter(d => d.type === 'frelon')
        .filter(d => {
          const dt = toJsDate(d.date);
          return dt && (now - dt.getTime()) <= NEST.TIME_WINDOW_DAYS * 86400000;
        });

      if (fresh.length < 2) return;

      // Aides quantit√© : clamp pour √©viter outliers
      const qEff = (q) => Math.min(Math.max(Number(q) || 0, 0), NEST.Q_MAX);

      // Poids pour le score S(x)
      const Wscore = fresh.map(d => {
        const dt = toJsDate(d.date);
        const days = (now - dt.getTime()) / 86400000;
        const wQty = Math.pow(1 + qEff(d.quantity), NEST.BETA);
        const wTime = Math.exp(-days / NEST.TAU_DAYS);
        return wQty * wTime;
      });

      // Poids pour le clustering
      const Wcluster = fresh.map(d => {
        const dt = toJsDate(d.date);
        const days = (now - dt.getTime()) / 86400000;
        const wQty = Math.pow(1 + qEff(d.quantity), NEST.BETA_CLUSTER);
        const wTime = Math.exp(-days / NEST.TAU_DAYS);
        return wQty * wTime;
      });

      // Clusters pond√©r√©s
      const pts = fresh.map(d => ({ lat: d.lat, lng: d.lng }));
      const { labels } = dbscanWeighted(pts, Wcluster, NEST.R95_M, NEST.MIN_CLUSTER_WEIGHT);

      // Si aucun cluster valide, fallback: tout en un seul bloc
      let cidSet = new Set(labels.filter(l => l >= 0));
      if (cidSet.size === 0) {
        cidSet = new Set([0]);
        labels.fill(0);
      }
      const clusterIds = [...cidSet];

      // Rayon pour la probabilit√© p
      const rp = NEST.SIGMA_M * Math.sqrt(-2 * Math.log(1 - NEST.PROB_P));

      for (const cid of clusterIds) {
        const idxs = labels.map((v, i) => (v === cid ? i : -1)).filter(i => i >= 0);
        if (idxs.length < 2) continue;

        // Bounds + marge R95
        let minLat = +Infinity, maxLat = -Infinity, minLng = +Infinity, maxLng = -Infinity;
        idxs.forEach(i => {
          const { lat, lng } = fresh[i];
          if (lat < minLat) minLat = lat; if (lat > maxLat) maxLat = lat;
          if (lng < minLng) minLng = lng; if (lng > maxLng) maxLng = lng;
        });
        const lat0 = (minLat + maxLat) / 2;
        minLat -= metersToDegLat(NEST.R95_M);
        maxLat += metersToDegLat(NEST.R95_M);
        minLng -= metersToDegLng(NEST.R95_M, lat0);
        maxLng += metersToDegLng(NEST.R95_M, lat0);

        // Grille
        const stepLat = metersToDegLat(NEST.GRID_STEP_M);
        const stepLng = metersToDegLng(NEST.GRID_STEP_M, lat0);

        // Chercher le maximum de S(x) = Œ£ Wscore_i * exp(-d^2/(2œÉ^2))
        let best = { score: -1, lat: null, lng: null };
        for (let lat = minLat; lat <= maxLat; lat += stepLat) {
          for (let lng = minLng; lng <= maxLng; lng += stepLng) {
            let s = 0;
            for (const i of idxs) {
              const d = haversineMeters({ lat, lng }, pts[i]);
              s += Wscore[i] * Math.exp(-(d * d) / (2 * NEST.SIGMA_M * NEST.SIGMA_M));
            }
            if (s > best.score) best = { score: s, lat, lng };
          }
        }
        if (best.lat == null) continue;

        // Construire la liste d√©taill√©e pour la popup (tri par poids d√©croissant)
        const rows = idxs.map(i => {
          const di = fresh[i];
          const dt = toJsDate(di.date);
          const ageDays = dt ? Math.round((now - dt.getTime()) / 86400000) : null;
          const dist = haversineMeters({ lat: best.lat, lng: best.lng }, { lat: di.lat, lng: di.lng });
          const q = qEff(di.quantity);
          const wQty = Math.pow(1 + q, NEST.BETA);
          const wTime = dt ? Math.exp(-((now - dt.getTime()) / 86400000) / NEST.TAU_DAYS) : 0;
          const w = wQty * wTime;
          return {
            dateStr: formatDate(di.date),
            ageDays,
            q,
            lat: di.lat,
            lng: di.lng,
            dist,
            weight: w,
            desc: di.description ? String(di.description) : ''
          };
        }).sort((a,b) => b.weight - a.weight);

        const itemsHtml = rows.map(r => {
          const desc = r.desc ? ' ‚Äî ' + escapeHtml(r.desc.slice(0, 140)) + (r.desc.length > 140 ? '‚Ä¶' : '') : '';
          return `<li>
            <strong>${r.q}</strong> frelon(s) ‚Äî ${r.dateStr}${r.ageDays!=null?` (${r.ageDays} j)`:''} ‚Äî ${Math.round(r.dist)} m du centre
            <br><small>${r.lat.toFixed(5)}, ${r.lng.toFixed(5)}${desc}</small>
          </li>`;
        }).join('');

        const totalQty = rows.reduce((acc,r)=>acc + r.q, 0);

        // Cercle
        const circle = L.circle([best.lat, best.lng], {
          radius: rp,
          color: '#FF7A1A',
          fillColor: '#FF7A1A',
          fillOpacity: 0.15,
          weight: 2,
          dashArray: '6 6'
        });

        const popupHtml = `
          <strong>Zone probable de nid</strong><br>
          p = ${(NEST.PROB_P * 100).toFixed(0)}% ‚Äî Rayon ‚âà ${(rp / 1000).toFixed(2)} km<br>
          Bas√© sur ${idxs.length} d√©claration(s) r√©cente(s) ‚Äî Total frelons ‚âà ${totalQty}
          <details style="margin-top:6px;">
            <summary>Voir les d√©clarations (${idxs.length})</summary>
            <ol style="margin:6px 0 0 18px; padding:0; max-height:180px; overflow:auto;">
              ${itemsHtml || '<li>Aucune</li>'}
            </ol>
          </details>
        `;

        circle.bindPopup(popupHtml);

        state.probLayers.push(circle);
        if (state.showZones) circle.addTo(map);
      }
    }

    async function loadData() {
      const badge = document.getElementById('countBadge');
      badge.textContent = 'Chargement‚Ä¶';

      // Trie par date descendante pour avoir les plus r√©cents d'abord
      const q = query(collection(db, 'declaration'), orderBy('date', 'desc'));
      const snap = await getDocs(q);

      state.raw = [];

      // Nettoyage anciens marqueurs
      state.markers.forEach(m => map.removeLayer(m));
      state.markers = [];

      snap.forEach(doc => {
        const d = doc.data();
        if (typeof d.lat !== 'number' || typeof d.lng !== 'number') return;

        const type = (d.type === 'nid') ? 'nid' : 'frelon';
        const item = {
          type,
          lat: d.lat,
          lng: d.lng,
          quantity: typeof d.quantity === 'number' ? d.quantity : Number(d.quantity) || 0,
          date: d.date ?? null,
          description: d.description ?? ''
        };
        state.raw.push(item);

        const marker = makeMarker(item);
        state.markers.push(marker);
      });

      // --- Heatmap orange (visualisation) ---
      if (state.heatLayer) { map.removeLayer(state.heatLayer); state.heatLayer = null; }
      const heatPoints = state.raw.map(d => {
        const base = Math.min(Math.max(Number(d.quantity)||0, 0), NEST.Q_MAX);
        const weight = Math.max(0.2, Math.min(1, base / 10));
        return [d.lat, d.lng, weight];
      });
      if (heatPoints.length) {
        state.heatLayer = L.heatLayer(heatPoints, {
          radius: 28, blur: 18, maxZoom: 17,
          gradient: { 0.2: '#FFE8CC', 0.4: '#FFC285', 0.6: '#FF9A3A', 0.8: '#FF7A1A', 1.0: '#FF5A00' }
        }).addTo(map);
      }

      // --- Zones probables de nid (quantit√© prioritaire) ---
      buildProbableZones();

      applyFilters();
      fitToData();
      badge.textContent = `${state.raw.length} signalement(s)`;
    }

    // UI handlers
    document.getElementById('toggleFrelon').addEventListener('change', (e) => {
      state.filters.frelon = e.target.checked;
      applyFilters();
    });
    document.getElementById('toggleNid').addEventListener('change', (e) => {
      state.filters.nid = e.target.checked;
      applyFilters();
    });
    document.getElementById('toggleZones').addEventListener('change', (e) => {
      state.showZones = e.target.checked;
      state.probLayers.forEach(l => { if (state.showZones) l.addTo(map); else map.removeLayer(l); });
    });
    document.getElementById('refreshBtn').addEventListener('click', (e) => {
      e.preventDefault();
      loadData();
    });
    document.getElementById('locateBtn').addEventListener('click', () => {
      if (!navigator.geolocation) return showToast('G√©olocalisation non support√©e.');
      navigator.geolocation.getCurrentPosition(
        pos => { const { latitude, longitude } = pos.coords; map.setView([latitude, longitude], 13); },
        () => showToast('Position introuvable.')
      );
    });

    function showToast(msg) {
      const el = document.getElementById('toast');
      el.textContent = msg;
      el.classList.add('show');
      setTimeout(() => el.classList.remove('show'), 2500);
    }

    // Charge au d√©marrage
    loadData().catch(err => {
      console.error(err);
      showToast('Erreur de chargement des donn√©es');
      document.getElementById('countBadge').textContent = 'Erreur';
    });
  </script>
</body>
</html>
