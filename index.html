<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Carte des signalements ‚Äì Frelon asiatique (MVP)</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    :root {
      --bg: #0b1020;
      --panel: #131b33;
      --muted: #9fb0d0;
      --accent: #6ae28a;
      --accent-2: #e26a6a;
      --text: #e6ecff;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
    #app { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    header { display: flex; gap: 12px; align-items: center; padding: 10px 14px; background: var(--panel); border-bottom: 1px solid #202a4a; }
    header h1 { font-size: 16px; margin: 0; font-weight: 600; }
    .controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .badge { padding: 4px 8px; border-radius: 999px; font-size: 12px; background: #0e1630; border: 1px solid #243058; }
    .legend { display: flex; gap: 12px; align-items: center; }
    .dot { width: 10px; height: 10px; border-radius: 999px; display: inline-block; margin-right: 6px; }
    .dot-frelon { background: var(--accent); }
    .dot-nid { background: var(--accent-2); }
    #map { width: 100%; height: calc(100vh - 62px); }
    .btn { background: #1a2240; color: var(--text); border: 1px solid #2a3869; border-radius: 10px; padding: 6px 10px; cursor: pointer; font-size: 14px; }
    .btn:hover { background: #212c52; }
    .leaflet-popup-content { color: #0b1020; }
    .toast { position: fixed; top: 12px; right: 12px; background: #0e1630; border: 1px solid #243058; color: var(--text); padding: 10px 12px; border-radius: 12px; font-size: 13px; box-shadow: 0 6px 24px rgba(0,0,0,0.25); display: none; }
    .toast.show { display: block; }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>Carte des signalements ‚Äì Frelon asiatique</h1>
      <div class="controls">
        <span id="countBadge" class="badge">Chargement‚Ä¶</span>
        <div class="legend">
          <label><span class="dot dot-frelon"></span><input type="checkbox" id="toggleFrelon" checked> Frelons</label>
          <label><span class="dot dot-nid"></span><input type="checkbox" id="toggleNid" checked> Nids</label>
          <!-- Toggle zone probable -->
          <label><input type="checkbox" id="toggleZones" checked> Zone probable</label>
        </div>
        <button id="locateBtn" class="btn">üìç Autour de moi</button>
        <a class="btn" href="#" id="refreshBtn">üîÑ Actualiser</a>
      </div>
    </header>
    <div id="map"></div>
  </div>

  <div id="toast" class="toast">Position introuvable.</div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- Plugin Heatmap pour Leaflet -->
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

  <!-- Firebase v9 (modular) CDN -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getFirestore, collection, getDocs, query, orderBy } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

    // üëâ config Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyDBhvHztC4w2MYbQG2rTtdJgMiKMo4vos4",
      authDomain: "frelonsasiatiques-d71cc.firebaseapp.com",
      projectId: "frelonsasiatiques-d71cc",
      storageBucket: "frelonsasiatiques-d71cc.firebasestorage.app",
      messagingSenderId: "895220865652",
      appId: "1:895220865652:web:f9c3656604e4b8bb048f21",
      measurementId: "G-P6X6Z218K8"
    };

    // Init Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // ------- Leaflet map -------
    const map = L.map('map', { zoomControl: true, attributionControl: true }).setView([46.7, 2.5], 6); // Vue g√©n√©rale France
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const state = {
      markers: [],
      raw: [],
      heatLayer: null, // heatmap
      probLayers: [],  // cercles de zone probable
      filters: { frelon: true, nid: true },
      showZones: true
    };

    const colors = {
      frelon: '#6ae28a', // vert
      nid: '#e26a6a'     // rouge
    };

    // ----- Mod√®le de localisation de nid (r√©glages) -----
    const NEST = {
      TIME_WINDOW_DAYS: 21, // on garde les frelons r√©cents
      TAU_DAYS: 14,         // d√©croissance temporelle
      BETA: 0.7,            // pond√©ration des quantit√©s (sous-lin√©aire)
      R95_M: 1000,          // rayon o√π ~95% de l'activit√© se trouve
      GRID_STEP_M: 250,     // pas de grille (m)
      PROB_P: 0.6           // cercle qui contient p de proba (ex. 60%)
    };
    NEST.SIGMA_M = NEST.R95_M / 2.447; // ‚âà 408 m si R95 = 1000 m

    // --- Aides g√©o ---
    function toRad(d){ return d*Math.PI/180; }
    function haversineMeters(a, b){
      const R = 6371000;
      const dLat = toRad(b.lat - a.lat);
      const dLng = toRad(b.lng - a.lng);
      const sa = Math.sin(dLat/2), sb = Math.sin(dLng/2);
      const h = sa*sa + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*sb*sb;
      return 2*R*Math.asin(Math.sqrt(h));
    }
    function metersToDegLat(m){ return m / 111320; }
    function metersToDegLng(m, lat){ return m / (111320 * Math.cos(toRad(lat))); }

    // --- DBSCAN simple (pour plusieurs foyers √©ventuels) ---
    function dbscan(points, epsMeters, minPts){
      const n = points.length;
      const labels = Array(n).fill(-1); // -1: non visit√©, -2: bruit, >=0: cluster id
      let cid = 0;

      function neighbors(i){
        const res = [];
        for (let j=0;j<n;j++){
          if (i===j) continue;
          const d = haversineMeters(points[i], points[j]);
          if (d <= epsMeters) res.push(j);
        }
        return res;
      }

      for (let i=0;i<n;i++){
        if (labels[i] !== -1) continue;
        const neigh = neighbors(i);
        if (neigh.length+1 < minPts){ labels[i] = -2; continue; } // bruit
        labels[i] = cid;
        const seeds = [...neigh];
        for (let k=0;k<seeds.length;k++){
          const j = seeds[k];
          if (labels[j] === -2) labels[j] = cid;
          if (labels[j] !== -1) continue;
          labels[j] = cid;
          const neighj = neighbors(j);
          if (neighj.length+1 >= minPts){
            for (const x of neighj){ if (!seeds.includes(x)) seeds.push(x); }
          }
        }
        cid++;
      }
      return {labels, clusters: cid};
    }

    // --- Dates robustes ---
    function toJsDate(val) {
      if (!val) return null;
      if (val && typeof val.toDate === 'function') {
        return val.toDate();
      }
      if (val instanceof Date) {
        return isNaN(val.getTime()) ? null : val;
      }
      if (typeof val === 'number') {
        const d = new Date(val < 1e12 ? val * 1000 : val);
        return isNaN(d.getTime()) ? null : d;
      }
      if (typeof val === 'string') {
        const s = val.trim();
        if (/^\d{4}-\d{2}-\d{2}$/.test(s)) {
          const d = new Date(s + 'T00:00:00Z');
          return isNaN(d.getTime()) ? null : d;
        }
        const d = new Date(s);
        return isNaN(d.getTime()) ? null : d;
      }
      return null;
    }

    function formatDate(val) {
      const d = toJsDate(val);
      if (!d) return '‚Äî';
      const dd = String(d.getDate()).padStart(2, '0');
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const yyyy = d.getFullYear();
      return `${dd}-${mm}-${yyyy}`;
    }

    // --- Markers ---
    function makeMarker(d) {
      const color = d.type === 'nid' ? colors.nid : colors.frelon;
      const marker = L.circleMarker([d.lat, d.lng], {
        radius: Math.min(14, 6 + (Number(d.quantity) || 0)),
        color,
        fillColor: color,
        fillOpacity: 0.6,
        weight: 2
      });

      const title = d.type === 'nid' ? 'Nid signal√©' : 'Frelons observ√©s';
      const quantity = (d.quantity ?? '‚Äî');
      let seen = '‚Äî';
      try { seen = formatDate(d.date); } catch(_) {}

      marker.bindPopup(
        `<strong>${title}</strong><br>
         Quantit√© : ${quantity}<br>
         Vu le : ${seen}`
      );
      marker.__type = d.type;
      return marker;
    }

    function escapeHtml(str) {
      return String(str)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    function applyFilters() {
      state.markers.forEach(m => {
        const visible =
          (m.__type === 'nid' && state.filters.nid) ||
          (m.__type === 'frelon' && state.filters.frelon);
        if (visible) {
          m.addTo(map);
        } else {
          map.removeLayer(m);
        }
      });
      // La heatmap et les zones probables sont g√©r√©es s√©par√©ment.
    }

    function fitToData() {
      const visible = state.markers.filter(m => map.hasLayer(m));
      if (!visible.length) return;
      const group = L.featureGroup(visible);
      map.fitBounds(group.getBounds().pad(0.2));
    }

    // --- Construction des zones probables de nid ---
    function buildProbableZones() {
      // Supprimer les anciens cercles
      state.probLayers.forEach(l => map.removeLayer(l));
      state.probLayers = [];

      // Garder uniquement les signalements de frelons r√©cents
      const now = Date.now();
      const fresh = state.raw
        .filter(d => d.type === 'frelon')
        .filter(d => {
          const dt = toJsDate(d.date);
          return dt && (now - dt.getTime()) <= NEST.TIME_WINDOW_DAYS * 86400000;
        });

      if (fresh.length < 2) return; // pas assez de signalements

      // Poids par observation (quantit√© ^BETA * d√©croissance temporelle)
      const W = fresh.map(d => {
        const dt = toJsDate(d.date);
        const days = (now - dt.getTime()) / 86400000;
        const wQty = Math.pow(1 + Math.max(0, Number(d.quantity) || 0), NEST.BETA);
        const wTime = Math.exp(-days / NEST.TAU_DAYS);
        return wQty * wTime;
      });

      // Clusters (DBSCAN) pour d√©tecter plusieurs foyers potentiels
      const pts = fresh.map(d => ({ lat: d.lat, lng: d.lng }));
      const eps = NEST.R95_M;
      const { labels } = dbscan(pts, eps, 3);

      // D√©terminer les clusters valides ; fallback en un seul cluster si n√©cessaire
      let cidSet = new Set(labels.filter(l => l >= 0));
      if (cidSet.size === 0) {
        cidSet = new Set([0]);
        labels.fill(0);
      }
      const clusterIds = [...cidSet];

      const rp = NEST.SIGMA_M * Math.sqrt(-2 * Math.log(1 - NEST.PROB_P)); // rayon proba p

      for (const cid of clusterIds) {
        const idxs = labels.map((v, i) => (v === cid ? i : -1)).filter(i => i >= 0);
        if (idxs.length < 2) continue;

        // Bounds du cluster + marge = R95
        let minLat = +Infinity, maxLat = -Infinity, minLng = +Infinity, maxLng = -Infinity;
        idxs.forEach(i => {
          const { lat, lng } = fresh[i];
          if (lat < minLat) minLat = lat; if (lat > maxLat) maxLat = lat;
          if (lng < minLng) minLng = lng; if (lng > maxLng) maxLng = lng;
        });
        const lat0 = (minLat + maxLat) / 2;
        minLat -= metersToDegLat(NEST.R95_M);
        maxLat += metersToDegLat(NEST.R95_M);
        minLng -= metersToDegLng(NEST.R95_M, lat0);
        maxLng += metersToDegLng(NEST.R95_M, lat0);

        // Grille de calcul
        const stepLat = metersToDegLat(NEST.GRID_STEP_M);
        const stepLng = metersToDegLng(NEST.GRID_STEP_M, lat0);

        // Chercher le maximum de score S(x) = sum_i W_i * exp(-d^2/(2œÉ^2))
        let best = { score: -1, lat: null, lng: null };
        for (let lat = minLat; lat <= maxLat; lat += stepLat) {
          for (let lng = minLng; lng <= maxLng; lng += stepLng) {
            let s = 0;
            for (const i of idxs) {
              const d = haversineMeters({ lat, lng }, pts[i]);
              s += W[i] * Math.exp(-(d * d) / (2 * NEST.SIGMA_M * NEST.SIGMA_M));
            }
            if (s > best.score) best = { score: s, lat, lng };
          }
        }

        if (best.lat == null) continue;

        // Cercle de zone probable
        const circle = L.circle([best.lat, best.lng], {
          radius: rp,
          color: '#FF7A1A',
          fillColor: '#FF7A1A',
          fillOpacity: 0.15,
          weight: 2,
          dashArray: '6 6'
        });

        circle.bindPopup(
          `<strong>Zone probable de nid</strong><br>
           p = ${(NEST.PROB_P * 100).toFixed(0)}%<br>
           Rayon ‚âà ${(rp / 1000).toFixed(2)} km<br>
           Bas√© sur ${idxs.length} signalement(s) r√©cent(s)`
        );

        state.probLayers.push(circle);
        if (state.showZones) circle.addTo(map);
      }
    }

    async function loadData() {
      const badge = document.getElementById('countBadge');
      badge.textContent = 'Chargement‚Ä¶';

      // Trie par date descendante pour avoir les plus r√©cents d'abord
      const q = query(collection(db, 'declaration'), orderBy('date', 'desc'));
      const snap = await getDocs(q);

      state.raw = [];

      // Nettoyage anciens marqueurs
      state.markers.forEach(m => map.removeLayer(m));
      state.markers = [];

      snap.forEach(doc => {
        const d = doc.data();
        if (typeof d.lat !== 'number' || typeof d.lng !== 'number') return; // on ignore

        const type = (d.type === 'nid') ? 'nid' : 'frelon';
        const item = {
          type,
          lat: d.lat,
          lng: d.lng,
          quantity: typeof d.quantity === 'number' ? d.quantity : Number(d.quantity) || 0,
          date: d.date ?? null, // laiss√© tel quel, g√©r√© par formatDate()
          description: d.description ?? ''
        };
        state.raw.push(item);

        const marker = makeMarker(item);
        state.markers.push(marker);
      });

      // --- Heatmap orange √† partir des d√©clarations (toutes) ---
      if (state.heatLayer) {
        map.removeLayer(state.heatLayer);
        state.heatLayer = null;
      }

      // Poids: bas√© sur "quantity" (plancher 0.2, plafond 1)
      const heatPoints = state.raw.map(d => {
        const base = Number.isFinite(d.quantity) ? d.quantity : 1;
        const weight = Math.max(0.2, Math.min(1, base / 10)); // ajuste au besoin
        return [d.lat, d.lng, weight];
      });

      if (heatPoints.length) {
        state.heatLayer = L.heatLayer(heatPoints, {
          radius: 28,     // rayon du "halo"
          blur: 18,       // adoucissement
          maxZoom: 17,
          // d√©grad√© orange
          gradient: {
            0.2: '#FFE8CC',
            0.4: '#FFC285',
            0.6: '#FF9A3A',
            0.8: '#FF7A1A',
            1.0: '#FF5A00'
          }
        }).addTo(map);
      }

      // --- Zones probables de nid (√† partir des frelons) ---
      buildProbableZones();

      applyFilters();
      fitToData();
      badge.textContent = `${state.raw.length} signalement(s)`;
    }

    // UI handlers
    document.getElementById('toggleFrelon').addEventListener('change', (e) => {
      state.filters.frelon = e.target.checked;
      applyFilters();
    });

    document.getElementById('toggleNid').addEventListener('change', (e) => {
      state.filters.nid = e.target.checked;
      applyFilters();
    });

    document.getElementById('toggleZones').addEventListener('change', (e) => {
      state.showZones = e.target.checked;
      state.probLayers.forEach(l => {
        if (state.showZones) l.addTo(map);
        else map.removeLayer(l);
      });
    });

    document.getElementById('refreshBtn').addEventListener('click', (e) => {
      e.preventDefault();
      loadData();
    });

    document.getElementById('locateBtn').addEventListener('click', () => {
      if (!navigator.geolocation) return showToast('G√©olocalisation non support√©e.');
      navigator.geolocation.getCurrentPosition(
        pos => {
          const { latitude, longitude } = pos.coords;
          map.setView([latitude, longitude], 13);
        },
        () => showToast('Position introuvable.')
      );
    });

    function showToast(msg) {
      const el = document.getElementById('toast');
      el.textContent = msg;
      el.classList.add('show');
      setTimeout(() => el.classList.remove('show'), 2500);
    }

    // Charge au d√©marrage
    loadData().catch(err => {
      console.error(err);
      showToast('Erreur de chargement des donn√©es');
      document.getElementById('countBadge').textContent = 'Erreur';
    });
  </script>
</body>
</html>
