<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Carte des signalements ‚Äì Frelon asiatique (MVP)</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />

  <style>
    :root {
      --bg: #0b1020;
      --panel: #131b33;
      --muted: #9fb0d0;
      --frelon: #ffd34d;  /* jaune */
      --nid: #ff5a5a;     /* rouge */
      --prob: #3aa3ff;    /* bleu */
      --text: #e6ecff;
    }
    html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial; }
    #app { display: grid; grid-template-rows: auto 1fr; height: 100%; }
    header { display: flex; gap: 12px; align-items: center; padding: 10px 14px; background: var(--panel); border-bottom: 1px solid #202a4a; }
    header h1 { font-size: 16px; margin: 0; font-weight: 600; }
    .controls { display: flex; gap: 10px; align-items: center; flex-wrap: wrap; }
    .badge { padding: 4px 8px; border-radius: 999px; font-size: 12px; background: #0e1630; border: 1px solid #243058; }
    .legend { display: flex; gap: 14px; align-items: center; }
    #map { width: 100%; height: calc(100vh - 62px); }
    .btn { background: #1a2240; color: var(--text); border: 1px solid #2a3869; border-radius: 10px; padding: 6px 10px; cursor: pointer; font-size: 14px; }
    .btn:hover { background: #212c52; }
    .leaflet-popup-content { color: #0b1020; }
    .toast { position: fixed; top: 12px; right: 12px; background: #0e1630; border: 1px solid #243058; color: var(--text); padding: 10px 12px; border-radius: 12px; font-size: 13px; box-shadow: 0 6px 24px rgba(0,0,0,0.25); display: none; }
    .toast.show { display: block; }

    /* --- Ic√¥nes "pointeur" en CSS (utilis√©es via L.divIcon) --- */
    .pin {
      position: relative;
      width: 22px; height: 22px;
      border-radius: 50% 50% 50% 0;
      transform: rotate(-45deg);
      box-shadow: 0 1px 4px rgba(0,0,0,.4);
      border: 1px solid rgba(0,0,0,.25);
    }
    .pin::after {
      content: '';
      position: absolute;
      width: 8px; height: 8px;
      left: 7px; top: 7px;
      background: #fff;
      border-radius: 50%;
      transform: rotate(45deg);
    }
    .pin-red { background: var(--nid); }
    .pin-yellow { background: var(--frelon); }
    .pin-blue { background: var(--prob); }

    /* Version r√©duite pour la l√©gende */
    .pin.pin-sm { width: 16px; height: 16px; }
    .pin.pin-sm::after { width: 6px; height: 6px; left: 5px; top: 5px; }
  </style>
</head>
<body>
  <div id="app">
    <header>
      <h1>Carte des signalements ‚Äì Frelon asiatique</h1>
      <div class="controls">
        <span id="countBadge" class="badge">Chargement‚Ä¶</span>
        <div class="legend">
          <label style="display:flex;align-items:center;gap:6px;">
            <span class="pin pin-sm pin-yellow"></span>
            <input type="checkbox" id="toggleFrelon" checked> Frelons
          </label>
          <label style="display:flex;align-items:center;gap:6px;">
            <span class="pin pin-sm pin-red"></span>
            <input type="checkbox" id="toggleNid" checked> Nids
          </label>
          <label style="display:flex;align-items:center;gap:6px;">
            <span class="pin pin-sm pin-blue"></span>
            <input type="checkbox" id="toggleZones" checked> Zones probables
          </label>
        </div>
        <button id="locateBtn" class="btn">üìç Autour de moi</button>
        <a class="btn" href="#" id="refreshBtn">üîÑ Actualiser</a>
      </div>
    </header>
    <div id="map"></div>
  </div>

  <div id="toast" class="toast">Position introuvable.</div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- Plugin Heatmap pour Leaflet -->
  <script src="https://unpkg.com/leaflet.heat/dist/leaflet-heat.js"></script>

  <!-- Firebase v9 (modular) CDN -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-app.js";
    import { getFirestore, collection, getDocs, query, orderBy } from "https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore.js";

    // üëâ config Firebase
    const firebaseConfig = {
      apiKey: "AIzaSyDBhvHztC4w2MYbQG2rTtdJgMiZKMo4vos4", // (reprend ta cl√© d‚Äôorigine)
      authDomain: "frelonsasiatiques-d71cc.firebaseapp.com",
      projectId: "frelonsasiatiques-d71cc",
      storageBucket: "frelonsasiatiques-d71cc.firebasestorage.app",
      messagingSenderId: "895220865652",
      appId: "1:895220865652:web:f9c3656604e4b8bb048f21",
      measurementId: "G-P6X6Z218K8"
    };

    // Init Firebase
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);

    // ------- Leaflet map -------
    const map = L.map('map', { zoomControl: true, attributionControl: true }).setView([46.7, 2.5], 6); // Vue g√©n√©rale France
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '&copy; OpenStreetMap contributors'
    }).addTo(map);

    const state = {
      markers: [],      // pointeurs frelons/nids
      raw: [],
      heatLayer: null,  // heatmap
      probLayers: [],   // cercle(s) + pointeur(s) bleus
      filters: { frelon: true, nid: true },
      showZones: true
    };

    // ----- R√©glages (favoriser la QUANTIT√â de frelons) -----
    const NEST = {
      TIME_WINDOW_DAYS: 21,
      TAU_DAYS: 14,
      BETA: 1.0,
      BETA_CLUSTER: 1.0,
      MIN_CLUSTER_WEIGHT: 6,
      Q_MAX: 50,
      R95_M: 1000,
      GRID_STEP_M: 250,
      PROB_P: 0.6
    };
    NEST.SIGMA_M = NEST.R95_M / 2.447; // ‚âà 408 m si R95=1000 m

    // --- Aides g√©o ---
    function toRad(d){ return d*Math.PI/180; }
    function haversineMeters(a, b){
      const R = 6371000;
      const dLat = toRad(b.lat - a.lat);
      const dLng = toRad(b.lng - a.lng);
      const sa = Math.sin(dLat/2), sb = Math.sin(dLng/2);
      const h = sa*sa + Math.cos(toRad(a.lat))*Math.cos(toRad(b.lat))*sb*sb;
      return 2*R*Math.asin(Math.sqrt(h));
    }
    function metersToDegLat(m){ return m / 111320; }
    function metersToDegLng(m, lat){ return m / (111320 * Math.cos(toRad(lat))); }

    // --- Ic√¥nes pointeur ---
    function pinIcon(color){
      return L.divIcon({
        className: `pin pin-${color}`,
        iconSize: [22, 22],
        iconAnchor: [11, 22],   // pointe du pin
        popupAnchor: [0, -18]
      });
    }

    // --- DBSCAN pond√©r√© ---
    function dbscanWeighted(points, weights, epsMeters, minWeight){
      const n = points.length;
      const labels = Array(n).fill(-1); // -1: non visit√©, -2: bruit, >=0: cluster id
      let cid = 0;

      function neighbors(i){
        const idxs = [];
        for (let j=0;j<n;j++){
          if (i===j) continue;
          if (haversineMeters(points[i], points[j]) <= epsMeters) idxs.push(j);
        }
        return idxs;
      }
      function neighWeight(i, neighIdxs){
        let s = weights[i];
        for (const j of neighIdxs) s += weights[j];
        return s;
      }

      for (let i=0;i<n;i++){
        if (labels[i] !== -1) continue;
        const neigh = neighbors(i);
        if (neighWeight(i, neigh) < minWeight){ labels[i] = -2; continue; } // bruit
        labels[i] = cid;
        const seeds = [...neigh];
        for (let k=0;k<seeds.length;k++){
          const j = seeds[k];
          if (labels[j] === -2) labels[j] = cid;
          if (labels[j] !== -1) continue;
          labels[j] = cid;
          const nj = neighbors(j);
          if (neighWeight(j, nj) >= minWeight){
            for (const x of nj){ if (!seeds.includes(x)) seeds.push(x); }
          }
        }
        cid++;
      }
      return {labels, clusters: cid};
    }

    // --- Dates robustes ---
    function toJsDate(val) {
      if (!val) return null;
      if (val && typeof val.toDate === 'function') return val.toDate();
      if (val instanceof Date) return isNaN(val.getTime()) ? null : val;
      if (typeof val === 'number') {
        const d = new Date(val < 1e12 ? val * 1000 : val);
        return isNaN(d.getTime()) ? null : d;
      }
      if (typeof val === 'string') {
        const s = val.trim();
        if (/^\d{4}-\d{2}-\d{2}$/.test(s)) {
          const d = new Date(s + 'T00:00:00Z');
          return isNaN(d.getTime()) ? null : d;
        }
        const d = new Date(s);
        return isNaN(d.getTime()) ? null : d;
      }
      return null;
    }

    function formatDate(val) {
      const d = toJsDate(val);
      if (!d) return '‚Äî';
      const dd = String(d.getDate()).padStart(2, '0');
      const mm = String(d.getMonth() + 1).padStart(2, '0');
      const yyyy = d.getFullYear();
      return `${dd}-${mm}-${yyyy}`;
    }

    // --- Markers frelons/nids (POINTEURS) ---
    function makeMarker(d) {
      const icon = d.type === 'nid' ? pinIcon('red') : pinIcon('yellow');
      const marker = L.marker([d.lat, d.lng], { icon });

      const title = d.type === 'nid' ? 'Nid signal√©' : 'Frelons observ√©s';
      const quantity = (d.quantity ?? '‚Äî');
      let seen = '‚Äî';
      try { seen = formatDate(d.date); } catch(_) {}

      marker.bindPopup(
        `<strong>${title}</strong><br>
         Quantit√© : ${quantity}<br>
         Vu le : ${seen}`
      );
      marker.__type = d.type;
      return marker;
    }

    function escapeHtml(str) {
      return String(str)
        .replaceAll('&', '&amp;')
        .replaceAll('<', '&lt;')
        .replaceAll('>', '&gt;')
        .replaceAll('"', '&quot;')
        .replaceAll("'", '&#039;');
    }

    function applyFilters() {
      state.markers.forEach(m => {
        const visible =
          (m.__type === 'nid' && state.filters.nid) ||
          (m.__type === 'frelon' && state.filters.frelon);
        if (visible) m.addTo(map); else map.removeLayer(m);
      });
      // Heatmap et zones probables g√©r√©es s√©par√©ment.
    }

    function fitToData() {
      const visible = state.markers.filter(m => map.hasLayer(m));
      if (!visible.length) return;
      const group = L.featureGroup(visible);
      map.fitBounds(group.getBounds().pad(0.2));
    }

    // --- Construction des zones probables de nid (quantit√© prioritaire) ---
    function buildProbableZones() {
      // Nettoyage (cercle + marqueurs bleus)
      state.probLayers.forEach(l => map.removeLayer(l));
      state.probLayers = [];

      const now = Date.now();
      const fresh = state.raw
        .filter(d => d.type === 'frelon')
        .filter(d => {
          const dt = toJsDate(d.date);
          return dt && (now - dt.getTime()) <= NEST.TIME_WINDOW_DAYS * 86400000;
        });
      if (fresh.length < 2) return;

      const qEff = (q) => Math.min(Math.max(Number(q) || 0, 0), NEST.Q_MAX);

      // Poids score / clustering
      const Wscore = fresh.map(d => {
        const dt = toJsDate(d.date);
        const days = (now - dt.getTime()) / 86400000;
        return Math.pow(1 + qEff(d.quantity), NEST.BETA) * Math.exp(-days / NEST.TAU_DAYS);
      });
      const Wcluster = fresh.map(d => {
        const dt = toJsDate(d.date);
        const days = (now - dt.getTime()) / 86400000;
        return Math.pow(1 + qEff(d.quantity), NEST.BETA_CLUSTER) * Math.exp(-days / NEST.TAU_DAYS);
      });

      const pts = fresh.map(d => ({ lat: d.lat, lng: d.lng }));
      const { labels } = dbscanWeighted(pts, Wcluster, NEST.R95_M, NEST.MIN_CLUSTER_WEIGHT);

      let cidSet = new Set(labels.filter(l => l >= 0));
      if (cidSet.size === 0) { cidSet = new Set([0]); labels.fill(0); }
      const clusterIds = [...cidSet];

      const rp = NEST.SIGMA_M * Math.sqrt(-2 * Math.log(1 - NEST.PROB_P)); // rayon p

      for (const cid of clusterIds) {
        const idxs = labels.map((v, i) => (v === cid ? i : -1)).filter(i => i >= 0);
        if (idxs.length < 2) continue;

        // Bounds + marge
        let minLat = +Infinity, maxLat = -Infinity, minLng = +Infinity, maxLng = -Infinity;
        idxs.forEach(i => {
          const { lat, lng } = fresh[i];
          if (lat < minLat) minLat = lat; if (lat > maxLat) maxLat = lat;
          if (lng < minLng) minLng = lng; if (lng > maxLng) maxLng = lng;
        });
        const lat0 = (minLat + maxLat) / 2;
        minLat -= metersToDegLat(NEST.R95_M);
        maxLat += metersToDegLat(NEST.R95_M);
        minLng -= metersToDegLng(NEST.R95_M, lat0);
        maxLng += metersToDegLng(NEST.R95_M, lat0);

        // Grille
        const stepLat = metersToDegLat(NEST.GRID_STEP_M);
        const stepLng = metersToDegLng(NEST.GRID_STEP_M, lat0);

        // Max du score S(x)
        let best = { score: -1, lat: null, lng: null };
        for (let lat = minLat; lat <= maxLat; lat += stepLat) {
          for (let lng = minLng; lng <= maxLng; lng += stepLng) {
            let s = 0;
            for (const i of idxs) {
              const d = haversineMeters({ lat, lng }, pts[i]);
              s += Wscore[i] * Math.exp(-(d * d) / (2 * NEST.SIGMA_M * NEST.SIGMA_M));
            }
            if (s > best.score) best = { score: s, lat, lng };
          }
        }
        if (best.lat == null) continue;

        // Pr√©parer les d√©tails pour la popup (tri par poids d√©croissant)
        const nowMs = Date.now();
        const rows = idxs.map(i => {
          const di = fresh[i];
          const dt = toJsDate(di.date);
          const ageDays = dt ? Math.round((nowMs - dt.getTime()) / 86400000) : null;
          const dist = haversineMeters({ lat: best.lat, lng: best.lng }, { lat: di.lat, lng: di.lng });
          const q = qEff(di.quantity);
          const w = Math.pow(1 + q, NEST.BETA) * (dt ? Math.exp(-((nowMs - dt.getTime())/86400000)/NEST.TAU_DAYS) : 0);
          return {
            dateStr: formatDate(di.date), ageDays, q,
            lat: di.lat, lng: di.lng, dist, weight: w,
            desc: di.description ? String(di.description) : ''
          };
        }).sort((a,b) => b.weight - a.weight);

        const itemsHtml = rows.map(r => {
          const desc = r.desc ? ' ‚Äî ' + escapeHtml(r.desc.slice(0, 140)) + (r.desc.length > 140 ? '‚Ä¶' : '') : '';
          return `<li>
            <strong>${r.q}</strong> frelon(s) ‚Äî ${r.dateStr}${r.ageDays!=null?` (${r.ageDays} j)`:''} ‚Äî ${Math.round(r.dist)} m du centre
            <br><small>${r.lat.toFixed(5)}, ${r.lng.toFixed(5)}${desc}</small>
          </li>`;
        }).join('');
        const totalQty = rows.reduce((acc,r)=>acc + r.q, 0);

        const popupHtml = `
          <strong>Zone probable de nid</strong><br>
          p = ${(NEST.PROB_P * 100).toFixed(0)}% ‚Äî Rayon ‚âà ${(rp / 1000).toFixed(2)} km<br>
          Bas√© sur ${idxs.length} d√©claration(s) r√©cente(s) ‚Äî Total frelons ‚âà ${totalQty}
          <details style="margin-top:6px;">
            <summary>Voir les d√©clarations (${idxs.length})</summary>
            <ol style="margin:6px 0 0 18px; padding:0; max-height:180px; overflow:auto;">
              ${itemsHtml || '<li>Aucune</li>'}
            </ol>
          </details>
        `;

        // Cercle BLEU
        const circle = L.circle([best.lat, best.lng], {
          radius: rp,
          color: 'var(--prob)',
          fillColor: 'var(--prob)',
          fillOpacity: 0.12,
          weight: 2
        }).bindPopup(popupHtml);

        // Pointeur BLEU √† l'√©picentre
        const centerMarker = L.marker([best.lat, best.lng], { icon: pinIcon('blue') })
          .bindPopup(popupHtml);

        state.probLayers.push(circle, centerMarker);
        if (state.showZones) { circle.addTo(map); centerMarker.addTo(map); }
      }
    }

    async function loadData() {
      const badge = document.getElementById('countBadge');
      badge.textContent = 'Chargement‚Ä¶';

      // Trie par date descendante pour avoir les plus r√©cents d'abord
      const q = query(collection(db, 'declaration'), orderBy('date', 'desc'));
      const snap = await getDocs(q);

      state.raw = [];

      // Nettoyage anciens marqueurs
      state.markers.forEach(m => map.removeLayer(m));
      state.markers = [];

      snap.forEach(doc => {
        const d = doc.data();
        if (typeof d.lat !== 'number' || typeof d.lng !== 'number') return;

        const type = (d.type === 'nid') ? 'nid' : 'frelon';
        const item = {
          type,
          lat: d.lat,
          lng: d.lng,
          quantity: typeof d.quantity === 'number' ? d.quantity : Number(d.quantity) || 0,
          date: d.date ?? null,
          description: d.description ?? ''
        };
        state.raw.push(item);

        const marker = makeMarker(item); // POINTEUR rouge/jaune
        state.markers.push(marker);
      });

      // Ajout des markers selon filtres
      applyFilters();

      // --- Heatmap orange (visualisation) ---
      if (state.heatLayer) { map.removeLayer(state.heatLayer); state.heatLayer = null; }
      const heatPoints = state.raw.map(d => {
        const base = Math.min(Math.max(Number(d.quantity)||0, 0), NEST.Q_MAX);
        const weight = Math.max(0.2, Math.min(1, base / 10));
        return [d.lat, d.lng, weight];
      });
      if (heatPoints.length) {
        state.heatLayer = L.heatLayer(heatPoints, {
          radius: 28, blur: 18, maxZoom: 17,
          gradient: { 0.2: '#FFE8CC', 0.4: '#FFC285', 0.6: '#FF9A3A', 0.8: '#FF7A1A', 1.0: '#FF5A00' }
        }).addTo(map);
      }

      // --- Zones probables de nid (BLEU) ---
      buildProbableZones();

      fitToData();
      badge.textContent = `${state.raw.length} signalement(s)`;
    }

    // UI handlers
    document.getElementById('toggleFrelon').addEventListener('change', (e) => {
      state.filters.frelon = e.target.checked;
      applyFilters();
    });
    document.getElementById('toggleNid').addEventListener('change', (e) => {
      state.filters.nid = e.target.checked;
      applyFilters();
    });
    document.getElementById('toggleZones').addEventListener('change', (e) => {
      state.showZones = e.target.checked;
      state.probLayers.forEach(l => { if (state.showZones) l.addTo(map); else map.removeLayer(l); });
    });
    document.getElementById('refreshBtn').addEventListener('click', (e) => {
      e.preventDefault();
      loadData();
    });
    document.getElementById('locateBtn').addEventListener('click', () => {
      if (!navigator.geolocation) return showToast('G√©olocalisation non support√©e.');
      navigator.geolocation.getCurrentPosition(
        pos => { const { latitude, longitude } = pos.coords; map.setView([latitude, longitude], 13); },
        () => showToast('Position introuvable.')
      );
    });

    function showToast(msg) {
      const el = document.getElementById('toast');
      el.textContent = msg;
      el.classList.add('show');
      setTimeout(() => el.classList.remove('show'), 2500);
    }

    // Charge au d√©marrage
    loadData().catch(err => {
      console.error(err);
      showToast('Erreur de chargement des donn√©es');
      document.getElementById('countBadge').textContent = 'Erreur';
    });
  </script>
</body>
</html>
